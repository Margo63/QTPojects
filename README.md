### Закрепляемые знания:
Работа с сигналами и слотами. Работа с qml для создания простого визуального интерфейса. MouseArea. Условия. Таймер.

### Задача:
Реализовать простую игру для кошек. По экрану перемещается объект. При нажатии на него, он должен появляться в новом месте.


### Решение:
Реализовать движение объекта по таймеру и обработку столкновений с границами экрана. При нажатии на объекте, он должен появляться в новом месте экрана.

Создайте приложения под две версии устройств: android и desktop. Переключитесь на версию desktop.

В первую очередь создайте мышь (круг), которая в дальнейшем будет осуществлять движение. Для создания круга воспользуйтесь прямоугольником, которому укажите закругление. Чтобы получить круг, необходимо ширину (высоту) поделить на 2 (это значение будет являться радиусом).

В первую очередь реализуйте движение круга при нажатии на него. 
Создайте новый С++ файл. Назовите его Mouse. Настройки класса:

Перейдите к заголовочному файлу. 
Создайте свойства для координат объекта:

Объявите для них геттеры:

Для уведомления qml об изменениях объявите сигнал:

Укажите переменные для координат.

Далее для изменения позиции создайте слот:

Создайте реализацию геттеров и слота в классе mouse.cpp:

В геттерах верните соответствующее значение:


Перейдите к методу changePosition(). Здесь необходимо изменять положение мыши на случайное место на экране. Для этого воспользуйтесь функцией rand(), которая возвращает псевдослучайное целое число в диапазоне от 0 до максимального значения. Для генерации значений в определенном промежутке (по размерам окна) нужно поделить случайное число на максимальное значение (для координаты “х” это ширина окна, для координаты “у” это высота окна)..
Присвойте “x” случайное значение:

Необходимо случайное число ограничить шириной экрана. Она равна 640. Возьмите остаток от деления случайного числа на данное значение:

Высота окна 480. По аналогии сформируйте случайно значение:

После изменения координат вызовите сигнал, что зафиксировать изменения:

Перейдите к файлу main.cpp. Зарегистрируйте новый тип, чтобы обратиться в qml к созданному методу.


Вернитесь в qml файл. Для проверки работы описанной логики подключите зарегистрированный тип и создайте новый объект:

Для изменения положения объекта необходимо задать ему координаты. Координаты должны быть получены из ранее описанного класса:

Изменение координат происходит при нажатии на сам объект мыши. Вызовите MouseArea для прослушивания действия:

В обработке нажатия вызовите метод изменения позиции:

Запустите приложение. При нажатии на мышь она должна отображаться в новом месте:

Мышь выходит за пределы экрана. Чтобы этого не происходило вычтите из ширины и высоты (при формировании случайного значения) размеры  самого объекта:

При запуске, объект не должен уходить за пределы экрана.
Добавьте счет количества пойманных мышек. Для этого в заголовочном файле объявите новое свойство:

Создайте для него геттер и объявите переменную, которую будете возвращать:

Объявите сигнал, для оповещения об изменениях:

Для увеличения счета можно воспользоваться уже существующим слотом, так как смена позиции будет происходить только при нажатии на объект. Перейдите к реализации метода изменения положения мыши. В нем произведите увеличение значения:

Вызовите сигнал для оповещения об изменениях:

Добавьте реализацию геттера для получения значения:

Вернитесь в qml файл. Создайте в нем текстовое поле и выведите в нем счет:

Запустите приложение. Счет должен увеличиваться при нажатии на мышь:


Добавление таймера. 
Перейдите к заголовочному файлу. Объявите новый слот, для реализации движения мыши по таймеру. Объявите его:

Создайте его реализацию в mouse.cpp. В методе необходимо обработать ограничения движения мыши (чтобы она не выходила за пределы экрана) и прописать направление движения.
Пропишите движение объекта исходя из случайного значения. Случайное значение должно формироваться от -5 до 4. Сохраните значение в отдельную переменную:


Это значение будет определять шаг и направление движения. Если оба значения 0, необходимо сформировать новое значение:
 
Перед присваиванием значения координатам необходимо проверить, не выйдет ли мышь за пределы экрана. Для этого воспользуйтесь условием. Реализуйте проверку того, что мышь не выходит за границу вправо.
Верхний левый угол соответствует координате 0. Ширина мыши 100. Для того чтобы она полностью исчезла за пределами экрана следующий шаг должен быть меньше -100. Условие от обратного будет выглядеть как: “Следующий шаг должен быть больше -100”. Для вычисления следующего шага к текущей координате прибавьте полученное случайное выражение:


Пропишите ограничение справа. Для этого следующий шаг должен быть меньше ширины экрана:

Далее ограничение по “у”. Для движения вверх следующий шаг должен быть больше -100 (высота объекта):

Для движения вниз следующий шаг должен быть меньше 480:

Только если условие верно, увеличьте значение переменной координаты на шаг:

После изменения координаты необходимо оповестить об этом qml. Вызовите:

Вернитесь к qml.
Для постоянного движения объекта необходимо создать таймер. Воспользуйтесь встроенным таймером qml.
Подключите новую библиотеку с контроллерами:

Создайте объект таймер:

Задайте значение интервалу, который будет указывать через сколько миллисекунд будет совершен следующий тик:

Для того чтобы была не одна итерация, необходимо установить repeat в значение true (таймер не останавливался, пока не нажата кнопка “стоп”):

Для описания действия, которое будет происходить в триггере после интервала, воспользуйтесь свойством onTriggered:

Внутри вызовите ранее описанное движение:

Таймер необходимо запустить. Создайте кнопку, которая будет запускать игру. Чтобы кнопка не перекрывала счет, создайте строку, в нее перенесите счет:


При нажатии на кнопку запустите таймер:

Запустите приложение. Мышь после нажатия на кнопку начнет двигаться, но ее шаги будут мелкими. Для изменения этого дополните метод move():

srand - инициализация генератора случайных чисел. time - возвращает текущее время системы, можно передать 0 в качестве аргумента.

Сейчас объект мыши отображается поверх счета и кнопки запуска.  Измените начальное положение мыши. Для этого в заголовочном файле установите значение:



Статус игры.
Даже без запуска таймера мышь будет реагировать на нажатие. Это можно изменить. Перейдите к заголовочному файлу и объявите новое свойство, которое будет определять, запущена ли игра на выполнение:

Для изменения свойства воспользуйтесь сеттером (WRITE).
Создайте геттер для получения состояния:


Объявите сигнал, который будет оповещать об изменении состояния:


Для сеттера создайте новый слот, который будет принимать логическое выражение на вход:


Создайте переменную. Игра еще не запущена, значит состояние по умолчанию false:


Добавьте реализацию геттера в mouse.cpp. Укажите, что геттер возвращает значение:


Добавьте в файл реализацию сеттера. Укажите изменение значения:


Добавьте дополнительную проверку в метод changePosition(). Если значение state равна false, позиция объект не должна изменяться:


При нажатии на кнопку вызовите сеттер, чтобы изменить значение статуса игры:

Пока игра не началась, мышь не будет реагировать на нажатие.

Остановка игры.
Можно реализовать остановку игры. Для этого добавьте еще одну кнопку:

При нажатии на кнопку остановите таймер:

И укажите, что игра остановлена (присвойте переменной значение false):

Проверьте работу приложения:

Задача:
Отредактируйте движение мыши, чтобы она всегда оставалась в пределах окна.

